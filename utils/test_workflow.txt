# Mini Test for the workflow
import GeospatialAnalyzer

# Instantiate the analyzer
# Define your data paths (assuming these are correct from your Drive mount)
BUILDINGS_PATH   = "data/lamwo_buildings_V3.gpkg"
MINIGRIDS_PATH   = "data/updated_candidate_minigrids_merged.gpkg"
TILE_STATS_PATH  = "data/Lamwo_Tile_Stats_EE.csv"
PLAIN_TILES_PATH = "data/lamwo_sentinel_composites/lamwo_grid.geojson"

# Initialize the analyzer
analyzer = GeospatialAnalyzer(
    buildings_path=BUILDINGS_PATH,
    minigrids_path=MINIGRIDS_PATH,
    tile_stats_path=TILE_STATS_PATH,
    plain_tiles_path=PLAIN_TILES_PATH
    # database_uri="your_postgis_uri" # Uncomment if using PostGIS
)

# %%
# Simulate the LLM Workflow for the query "What is the average NDVI for the area around mini-grid 'Site B' within a 500 meter buffer?"

from shapely.geometry import Point # Need to import Point explicitly for the test

# Simulate the user's natural language query
user_query = "What is the average NDVI for the area around mini-grid 'Site B' within a 500 meter buffer?"

print(f"User Query: {user_query}")

# --- Simulate LLM processing ---
# The LLM would analyze the query and identify the intent and parameters.
# For this query, the LLM might decide to use these primitives:
# 1. get_site_geometry(site_id: str) -> Optional[Polygon]
# 2. buffer_geometry(geom: base.BaseGeometry, radius_m: float) -> base.BaseGeometry
# 3. avg_ndvi(region: Polygon) -> float

# Extract parameters from the query (simulated)
site_id_to_find = "Site B" # Example: LLM extracts 'Site B'
buffer_distance_m = 500   # Example: LLM extracts 500 meters

print(f"LLM identified site_id: '{site_id_to_find}' and buffer distance: {buffer_distance_m} meters.")
print("LLM selecting and calling primitives...")

# --- Execute Primitives (Simulated by direct function calls) ---

# Step 1: Get the geometry of the mini-grid site
mini_grid_geometry = analyzer.get_site_geometry(site_id_to_find)

if mini_grid_geometry is None:
    # Simulate LLM generating an error response
    llm_response = f"Sorry, I could not find the mini-grid site with ID '{site_id_to_find}'."
    print(llm_response)
else:
    print(f"Primitive 1 (get_site_geometry) executed. Retrieved geometry for '{site_id_to_find}'.")

    # Step 2: Buffer the mini-grid geometry
    # Pass the mini_grid_geometry which should have a CRS if loaded correctly
    buffered_area = analyzer.buffer_geometry(mini_grid_geometry, buffer_distance_m)
    print(f"Primitive 2 (buffer_geometry) executed. Created a {buffer_distance_m} meter buffer.")

    # Step 3: Calculate the average NDVI for the buffered area
    # Pass the buffered_area which should also have a CRS after buffering in a projected CRS
    average_ndvi_value = analyzer.avg_ndvi(buffered_area)
    print(f"Primitive 3 (avg_ndvi) executed. Calculated average NDVI.")

    # --- Simulate LLM generating the natural language response ---
    if np.isnan(average_ndvi_value):
        llm_response = f"I found the area around mini-grid site '{site_id_to_find}' with a {buffer_distance_m} meter buffer, but I couldn't calculate the average NDVI. This might be because there are no relevant tiles in that area or there was an error during the calculation."
    else:
        llm_response = f"The average NDVI for the area around mini-grid site '{site_id_to_find}' within a {buffer_distance_m} meter buffer is: {average_ndvi_value:.4f}"

    print("\n--- LLM Final Response ---")
    print(llm_response)

# You can also optionally visualize the buffered area and the mini-grid site
# Note: You would need to pass the geometries back from the primitives
# or have the visualization primitive accept geometries directly.

# Example of visualizing the buffer (requires storing the buffered_area)
if 'buffered_area' in locals() and buffered_area is not None:
    print("\nGenerating visualization...")

    # The visualize_layers primitive now handles adding specific geometries.
    # We can create a dummy analyzer for visualization or modify the existing one
    # to accept temporary geometries to display.
    # For this test, let's use the existing visualize_layers and center it on the site.

    # Ensure the original mini-grid geometry has a CRS to be used for centering
    minigrid_geom_for_vis_center = analyzer.get_site_geometry(site_id_to_find)


    map_output = analyzer.visualize_layers(
        center_point=minigrid_geom_for_vis_center, # Center the map on the mini-grid site
        zoom_start=14,
        show_minigrids=True,
        show_tile_stats=True # Show tiles with NDVI styling
    )

    # To add the buffer polygon to the map generated by visualize_layers,
    # you would typically modify visualize_layers or add the buffer as a separate layer
    # after getting the map object. Let's add the buffer here manually to the returned map.
    if buffered_area is not None:
        # Create a temporary GeoDataFrame for the buffer to visualize
        # Ensure the buffer geometry is in a geographic CRS for Folium
        buffer_gdf_vis, _ = analyzer._ensure_crs_for_calculation(buffered_area, analyzer.target_geographic_crs)


        folium.GeoJson(
            gpd.GeoSeries([buffer_gdf_vis]).to_json(), # Create GeoJSON from GeoSeries
            name=f'{buffer_distance_m}m Buffer around {site_id_to_find}',
            style_function=lambda feature: {
                'fillColor': 'blue',
                'color': 'blue',
                'weight': 2,
                'fillOpacity': 0.1
            }
        ).add_to(map_output)

    display(map_output) # Display the map in Colab

# %%
# User: given all of this, let's move on to defining the tool specifics
# Gemini: Absolutely. Let's define the tool specifications for each of its methods... (Full tool specifications provided below)

